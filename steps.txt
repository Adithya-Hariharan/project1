(Project: LLM Code Deployment — audit, missing work, and step-by-step plan)

Files reviewed
- `student/main.py` — a FastAPI-based implementation with GitHub repo creation, file push, Pages enabling, basic LLM placeholder generator that returns index.html, README.md, and LICENSE files.
- `instructor/send_task.py` — a simple script that POSTs a sample task to `http://localhost:8000/handle_task` (round=2 in the example).

Quick summary of what is implemented
- HTTP API: Not present as a FastAPI app instance in `student/main.py` (there are helpers but no FastAPI endpoints wired to accept POST /handle_task).
- Secret validation: `validate_secret(secret)` exists but only compares to `os.getenv('secret')` — okay as placeholder but needs improvement (timing-safe compare, env var name consistency).
- GitHub integration: `create_github_repo`, `push_files_to_repo`, `enable_github_pages`, and `get_sha_of_latest_commit` present, but they assume a GitHub username `Adithya-Hariharan` hard-coded in URLs and require `GITHUB_TOKEN` env var.
- LLM generation: `write_code_with_llm` exists but is deterministic and returns static HTML/README/LICENSE; no LLM API usage.
- Evaluation callback: code to POST back to `evaluation_url` is not implemented.
- Round handling: `write_code_with_llm` has a branch for round==2 but no orchestration code to handle rounds, logging, retries, or storage.

High-level missing items (required by the project spec)
1) FastAPI application and endpoint(s)
	- Implement HTTP POST `/handle_task` that:
	  - Accepts JSON, validates required fields
	  - Verifies `secret` against an env var or stored secret
	  - Returns HTTP 200 JSON immediately on success (or appropriate errors)
	  - Kicks off building the repo (synchronously or background task)

2) Background task / worker
	- Building, pushing to GitHub, and enabling Pages can take time. Use FastAPI BackgroundTasks or an async queue (Redis + RQ/Celery) for production. For student project, BackgroundTasks + retries is acceptable.

3) Secure secret handling
	- Use a well-named env var (e.g., `TASK_SECRET`) and compare using `hmac.compare_digest`.
	- Do NOT log or commit secrets; ensure attachments data URIs are handled safely and not leaked into git history.

4) Robust GitHub usage
	- Remove hard-coded username; derive from token via GET https://api.github.com/user
	- Create unique repo name from `task` value and timestamp/hash
	- Add `README.md`, `LICENSE`, and `index.html` (and attachments) using the GitHub Contents API or using local git + `git` CLI and push (safer for complex repos)
	- Enable GitHub Pages and poll for pages_url reachability (200 OK). Wait up to ~5 minutes with exponential backoff.
	- Ensure repo is public.

5) Avoid leaking secrets into git history
	- Never write environment variables or raw secrets to files that are committed.
	- When storing attachments, only store decoded files; if attachments are large or numerous, store them as-is but be mindful of size.

6) Notify evaluation_url
	- After a successful push and Pages is reachable, POST the JSON described by the spec (email, task, round, nonce, repo_url, commit_sha, pages_url)
	- Implement retries with backoff on non-200 responses and log attempts.

7) Round 2 (revise)
	- Accept additional POSTs with round==2, validate secret again, modify repo files, push, redeploy, and POST back to evaluation_url within 10 minutes.

8) Tests and checks
	- Add minimal unit tests for helper functions (secret validation, repo-name sanitizer)
	- Add a small integration test (optional) to run `send_task.py` against a local server.

Priority list (what to implement first)
1. Wire FastAPI app + `/handle_task` endpoint that validates input and returns 200.
2. Implement background task that calls `write_code_with_llm`, creates a repo, pushes files, enables pages, polls pages_url, and posts to evaluation_url with retries.
3. Fix GitHub username hard-coding and make token / secret env vars explicit in README and runtime instructions.
4. Secure secret comparison using `hmac.compare_digest`.
5. Add robust error handling and logging; prevent secret leakage.
6. Implement round 2 flow (modify files and re-deploy) and ensure evaluation callback for round 2.
7. Add small tests and a sample run guide.

Concrete step-by-step implementation plan (detailed)

Step 0 — prerequisites (local dev)
- Python 3.11 (project header indicates >=3.11)
- Windows PowerShell (instructions below)

Step 1 — create a virtual environment and install dependencies
- Required Python libraries for this project:
  - fastapi
  - uvicorn[standard]
  - requests
  - python-dotenv (optional, for local env)

PowerShell commands
```powershell
cd "C:\Users\Adith\OneDrive\Desktop\College\TDS\project1"
python -m venv .venv
.\.venv\Scripts\Activate.ps1
pip install --upgrade pip
pip install fastapi uvicorn[standard] requests python-dotenv
```

Step 2 — Update `student/main.py` to expose a FastAPI app and endpoint
- Add:
  - from fastapi import FastAPI, BackgroundTasks, HTTPException, Request
  - app = FastAPI()
  - POST /handle_task endpoint which:
	 - Validates JSON body fields (email, secret, task, round, nonce, brief, evaluation_url)
	 - Verifies secret using `hmac.compare_digest(secret, os.getenv("TASK_SECRET"))`
	 - Immediately returns a HTTP 200 JSON {"status":"accepted"}
	 - Starts a BackgroundTasks.add_task(build_and_notify, data)

Step 3 — Implement build_and_notify(data)
- High-level steps inside build_and_notify:
  1. Sanitize and create repo name: e.g., f"{data['task']}-{email.split('@')[0]}-{shorthash}" (lowercase, only [a-z0-9-]).
  2. Call `get_authenticated_user()` to find GH username from token.
  3. Call `create_github_repo(repo_name)`.
  4. Call `write_code_with_llm(data)` to get files to commit.
  5. For each attachment that is a data: URI, decode and add as file (sample.png or input files as specified).
  6. Call `push_files_to_repo(repo_name, files, round)`.
  7. Call `enable_github_pages(repo_name)` and poll pages URL for 200.
  8. Get commit SHA (latest) via `get_sha_of_latest_commit(repo_name)`.
  9. POST to `evaluation_url` with required JSON and do exponential backoff retries on non-200.

Step 4 — Improve helper functions
- Remove hard-coded username. Use token to get username for repo endpoints or accept `owner` param.
- Add small helpers:
  - decode_data_uri(uri) -> bytes
  - repo_name_sanitize(name) -> safe-name
  - poll_pages_url(pages_url, timeout=300)

Step 5 — Security and hygiene
- Use `hmac.compare_digest` for the secret check
- Log minimally and redact token/secret if logging request/response bodies
- Ensure attachments are not directly committed with any secrets inside them

Step 6 — Round 2 flow
- When `round == 2`:
  - Build updated files (LLM may return updated index.html and README.md)
  - Use `push_files_to_repo` which checks and updates existing files using the Contents API (code already attempts this but assumes username)
  - Re-enable/re-check GitHub Pages reachability and POST to evaluation_url.

Step 7 — Tests and manual run
- Add a tiny `tests/test_secret.py` unit test for secret compare.
- Run local server and test with `instructor/send_task.py`.

How to run locally (developer flow)
1. Start server:
```powershell
cd "C:\Users\Adith\OneDrive\Desktop\College\TDS\project1"
.\.venv\Scripts\Activate.ps1
uvicorn student.main:app --reload --host 0.0.0.0 --port 8000
```
2. In another shell, run the instructor script (edit the `payload['email']` and `secret` to match `TASK_SECRET` env var):
```powershell
python instructor\send_task.py
```

Env variables to set (example)
- GITHUB_TOKEN — a personal access token with repo and pages permissions.
- TASK_SECRET — the secret string to validate requests.
- OPTIONAL: LOG_LEVEL

PowerShell to set env for current session
```powershell
$env:GITHUB_TOKEN = "ghp_xxx"
$env:TASK_SECRET = "myproject2025"
```

Additional implementation notes and tips
- GitHub rate limits: If you hit API rate limits, back off and retry. Use conditional requests (ETags) for large flows.
- When creating the repo with `auto_init: true`, initial commit exists; pushing files using the Contents API will work, but if using git CLI you may prefer to initialize locally and push.
- To enable Pages more reliably, call the Pages API and then check the `source` and `status` objects.
- To prevent secrets in git history: never write env variables to files; scrub logs before storing; if a secret accidentally got committed, rotate tokens immediately.

Minimal code sketch to add to `student/main.py` (summary)
- Add:
  - FastAPI app and POST /handle_task
  - Background worker function `build_and_notify`
  - Helpers: `decode_data_uri`, `get_authenticated_user`, `poll_pages_url`, `safe_repo_name`

Libraries to install (recap)
- fastapi
- uvicorn[standard]
- requests
- python-dotenv (optional, for local .env)

Next steps I can take for you (pick one or more)
1) Implement the FastAPI endpoint and background flow in `student/main.py` now and run the server locally and verify `send_task.py` — I can make the edits and run quick smoke tests.
2) Only produce detailed code snippets and tests for you to paste in — no edits in the repo.
3) Add unit tests and a CI workflow (GitHub Actions) to automatically run evaluation checks.

Completion summary
- I read `student/main.py` and `instructor/send_task.py` and found core helper functions implemented but missing the FastAPI app wiring, evaluation callback, secure secret checks, GitHub username handling, Pages polling, and robust round2 orchestration.
- `steps.txt` now contains a prioritized list of missing features, a detailed step-by-step implementation plan, required libraries and PowerShell commands, and next-step options.

If you want, I can now implement option (1) and modify `student/main.py` to add the API endpoint and background worker. Reply with which option to proceed with.

